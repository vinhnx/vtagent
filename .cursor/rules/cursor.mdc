---
alwaysApply: true
---

# Cursor Rules for vtagent - Rust Code Analysis Tool

## Project Context
This is a Rust project called "vtagent" that appears to be a code analysis tool with tree-sitter support for multiple programming languages (Rust, Python, JavaScript, TypeScript, Go, Java).

## Code Style and Standards

### Rust Conventions
- Follow standard Rust naming conventions (snake_case for functions/variables, PascalCase for types)
- Use `anyhow` for error handling with descriptive error messages
- Prefer `thiserror` for custom error types when needed
- Use `clap` with derive macros for CLI argument parsing
- Follow the Rust API guidelines for public APIs

### Code Organization
- Keep modules focused and cohesive
- Use `src/lib.rs` for library code and `src/main.rs` for binary entry point
- Place CLI-specific code in the `cli/` directory
- Keep examples in the `examples/` directory
- Place benchmarks in the `benches/` directory

### Dependencies
- Use async/await with `tokio` for I/O operations
- Use `reqwest` with rustls for HTTP requests
- Use `serde` for serialization/deserialization
- Use `tree-sitter` for code parsing and analysis
- Use `walkdir` and `glob` for file system operations

## Development Guidelines

### Error Handling
- Use `anyhow::Result<T>` for functions that can fail
- Provide meaningful error messages with context
- Use `?` operator for error propagation
- Log errors appropriately using `console` crate

### Performance
- Use `tokio` for async operations
- Consider using `futures` for complex async workflows
- Profile with `criterion` benchmarks in the `benches/` directory
- Use `tree-sitter` efficiently for code parsing

### Testing
- Write unit tests in the same file as the code being tested
- Write integration tests in the `tests/` directory
- Use `cargo test` for running tests
- Consider property-based testing for complex algorithms

### Documentation
- Document public APIs with rustdoc comments
- Include examples in documentation
- Keep README.md up to date
- Document CLI usage and examples

## Tree-sitter Integration
- Use tree-sitter parsers for supported languages
- Handle parsing errors gracefully
- Consider performance implications of parsing large files
- Provide meaningful error messages for parsing failures

## CLI Design
- Use `clap` derive macros for argument parsing
- Provide clear help text and examples
- Use `console` and `owo-colors` for colored output
- Use `termimad` for rich terminal output when appropriate

## Security Considerations
- Be careful with file system operations
- Validate input from external sources
- Handle API keys securely (use environment variables)
- Consider rate limiting for external API calls

## Build Configuration
- Use release profile optimizations (codegen-units = 1, opt-level = 3, lto = true)
- Consider using `cargo clippy` for additional linting
- Use `cargo fmt` for code formatting

## File Organization
- Keep related functionality together
- Use appropriate module structure
- Consider the separation between library and binary code
- Place configuration files at the project root

## When Making Changes
- Ensure all tests pass
- Run `cargo clippy` and fix warnings
- Format code with `cargo fmt`
- Update documentation if needed
- Consider performance implications
- Test with various input files and edge cases