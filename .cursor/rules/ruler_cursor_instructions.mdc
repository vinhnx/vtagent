---
alwaysApply: true
---
<!-- Source: .ruler/AGENTS.md -->

# AGENTS.md

# Repository Guidelines

This document serves as a contributor guide for the vtagent repository, a Rust-based AI agent tool for context-aware code assistance.

## Project Structure & Module Organization

The project follows a modular Rust workspace structure:

- `vtagent-core/src/` - Core library containing modules for LLM integration, UI components, and commands
- `src/` - Main binary entry point
- `tests/` - Integration tests and test utilities
- `docs/` - Project documentation and guides
- `scripts/` - Build and development scripts
- `examples/` - Usage examples and demonstrations

Key modules include `gemini.rs` for AI integration, `ui/` for terminal interfaces, and `commands/` for CLI functionality.

For a detailed overview of the VTAgent architecture, see [VTAgent Architecture Documentation](docs/vtagent-architecture.md).

## Build, Test, and Development Commands

- `cargo build` - Build the project in debug mode
- `cargo build --release` - Build optimized release version
- `cargo test` - Run all tests
- `cargo check` - Quick compilation check without building
- `./run.sh` - Run the application in production mode
- `./run-debug.sh` - Run with debug logging enabled
- `cargo clippy` - Run linter for code quality checks

## Coding Style & Naming Conventions

- Use 4-space indentation (spaces, not tabs)
- Follow Rust standard naming: `snake_case` for functions/variables, `PascalCase` for types
- Line length limit: 100 characters
- Use `rustfmt` for automatic formatting
- Prefer explicit error handling over panics
- Document public APIs with rustdoc comments

## Testing Guidelines

- Use `cargo test` to run the test suite
- Integration tests go in `tests/` directory
- Unit tests are co-located with source code using `#[cfg(test)]`
- Test functions should be descriptive: `test_function_name_scenario_expected_result`
- Aim for meaningful test coverage of core functionality
- Mock external dependencies for reliable testing

## Commit & Pull Request Guidelines

- Use conventional commit format: `type(scope): description`
- Common types: `feat`, `fix`, `docs`, `refactor`, `test`, `chore`
- Keep commits atomic and focused on single changes
- Include issue references in commit messages when applicable
- Pull requests should include clear descriptions and test coverage
- Update documentation for user-facing changes

## Agent-Specific Instructions

- AI responses should maintain context awareness across conversations
- Tool integrations must handle timeouts and error recovery gracefully
- UI components should provide non-blocking status feedback
- Configuration changes require documentation updates
- New commands should follow the existing pattern in `commands/` module
- Use MCP tools for enhanced context awareness and external service integration
- All agent config should be in `vtagent.toml` (no hardcoding)
- Environment variables for sensitive data (API keys)

## Code Quality & Maintainability Principles

You are an engineer who writes code for **human brains, not machines**. You favour code that is simple to undertand and maintain. Remember at all times that the code you will be processed by human brain. The brain has a very limited capacity. People can only hold ~4 chunks in their working memory at once. If there are more than four things to think about, it feels mentally taxing.

Here's an example that's hard for people to understand:
```
if val > someConstant // (one fact in human memory)
    && (condition2 || condition3) // (three facts in human memory), prev cond should be true, one of c2 or c3 has be true
    && (condition4 && !condition5) { // (human memory overload), we are messed up by this point
    ...
}
```

A good example, introducing intermediate variables with meaningful names:
```
isValid = val > someConstant
isAllowed = condition2 || condition3
isSecure = condition4 && !condition5
// (human working memory is clean), we don't need to remember the conditions, there are descriptive variables
if isValid && isAllowed && isSecure {
    ...
}
```

- No useless "WHAT" comments, don't write a comment if it duplicates the code. Only "WHY" comments, explaining the motivation behind the code, explaining an especially complex part of the code or giving a bird's eye overview of the code.
- Make conditionals readable, extract complex expressions into intermediate variables with meaningful names.
- Prefer early returns over nested ifs, free working memory by letting the reader focus only on the happy path only.
- Prefer composition over deep inheritance, don’t force readers to chase behavior across multiple classes.
- Don't write shallow modules (complex interface, simple functionality). An example of shallow module: `MetricsProviderFactoryFactory`. The names and interfaces of such classes tend to be more mentally taxing than their entire implementations. Having too many shallow modules can make it difficult to understand the project. Not only do we have to keep in mind each module responsibilities, but also all their interactions.
- Prefer deep modules (simple interface, complex functionality) over many shallow ones.
- Don’t overuse language featuress, stick to the minimal subset. Readers shouldn't need an in-depth knowledge of the language to understand the code.
- Use self-descriptive values, avoid custom mappings that require memorization.
- Don’t abuse DRY, a little duplication is better than unnecessary dependencies.
- Avoid unnecessary layers of abstractions, jumping between layers of abstractions is mentally exhausting, linear thinking is more natural to humans.

## Project Context

This is a Rust project called "vtagent" that appears to be a code analysis tool with tree-sitter support for multiple programming languages (Rust, Python, JavaScript, TypeScript, Go, Java).

## Code Style and Standards

### Rust Conventions

- Follow standard Rust naming conventions (snake_case for functions/variables, PascalCase for types)
- Use `anyhow` for error handling with descriptive error messages
- Prefer `thiserror` for custom error types when needed
- Use `clap` with derive macros for CLI argument parsing
- Follow the Rust API guidelines for public APIs

### Code Organization

- Keep modules focused and cohesive
- Use `src/lib.rs` for library code and `src/main.rs` for binary entry point
- Place CLI-specific code in the `cli/` directory
- Keep examples in the `examples/` directory
- Place benchmarks in the `benches/` directory

### Dependencies

- Use async/await with `tokio` for I/O operations
- Use `reqwest` with rustls for HTTP requests
- Use `serde` for serialization/deserialization
- Use `tree-sitter` for code parsing and analysis
- Use `walkdir` and `glob` for file system operations

## Development Guidelines

### Error Handling

- Use `anyhow::Result<T>` for functions that can fail
- Provide meaningful error messages with context
- Use `?` operator for error propagation
- Log errors appropriately using `console` crate

### Performance

- Use `tokio` for async operations
- Consider using `futures` for complex async workflows
- Profile with `criterion` benchmarks in the `benches/` directory
- Use `tree-sitter` efficiently for code parsing

### Testing

- Write unit tests in the same file as the code being tested
- Write integration tests in the `tests/` directory
- Use `cargo test` for running tests
- Consider property-based testing for complex algorithms

### Documentation

- Document public APIs with rustdoc comments
- Include examples in documentation
- Keep README.md up to date
- Document CLI usage and examples
- Document (.md) files must put in ./docs folder. don't put any unrelated files in root folder. THIS IS IMPORTANT

## Tree-sitter Integration

- Use tree-sitter parsers for supported languages
- Handle parsing errors gracefully
- Consider performance implications of parsing large files
- Provide meaningful error messages for parsing failures

## CLI Design

- Use `clap` derive macros for argument parsing
- Provide clear help text and examples
- Use `console` and `owo-colors` for colored output
- Use `termimad` for rich terminal output when appropriate

## Security Considerations

- Be careful with file system operations
- Validate input from external sources
- Handle API keys securely (use environment variables)
- Consider rate limiting for external API calls

## Build Configuration

- Use release profile optimizations (codegen-units = 1, opt-level = 3, lto = true)
- Consider using `cargo clippy` for additional linting
- Use `cargo fmt` for code formatting

## File Organization

- Keep related functionality together
- Use appropriate module structure
- Consider the separation between library and binary code
- Place configuration files at the project root

## When Making Changes

- Ensure all tests pass
- Run `cargo clippy` and fix warnings
- Format code with `cargo fmt`
- Update documentation if needed
- Consider performance implications
- Test with various input files and edge cases
- Prefered ripgrep for searching code
- DO NOT USE EMOJI THIS IS IMPORTANT
- Put all agent's configuration option to vtagent.toml. This is important, every logic should be read from this toml config instead of hardcode.
- Use MCP tools for enhanced context awareness if needed.
- Use `cargo check` instead of `cargo build` whenever possible
- Use `cargo nextest` Instead of `cargo test
- Put all markdown documentation files to ./docs folder. don't put any unrelated files in root folder. THIS IS IMPORTANT!
- Put all report documentation (md) files to ./docs folder. don't put any unrelated files in root folder. THIS IS IMPORTANT!
- Always check ./docs/models.json use to use latest LLM model. Don't guess the model id/name. THIS IS IMPORTANT!
- Always use vtagent-core/src/config/constants.rs for constant values. Don't hardcode any constant values, especially model id. THIS IS IMPORTANT!
