<!-- Generated by Ruler -->


<!-- Source: AGENTS.md -->

# Repository Guidelines


<!-- Source: .ruler/AGENTS.md -->

# AGENTS.md

## Project Context

This is a Rust project called "vtagent" that appears to be a code analysis tool with tree-sitter support for multiple programming languages (Rust, Python, JavaScript, TypeScript, Go, Java).

## Code Style and Standards

### Rust Conventions

- Follow standard Rust naming conventions (snake_case for functions/variables, PascalCase for types)
- Use `anyhow` for error handling with descriptive error messages
- Prefer `thiserror` for custom error types when needed
- Use `clap` with derive macros for CLI argument parsing
- Follow the Rust API guidelines for public APIs

### Code Organization

- Keep modules focused and cohesive
- Use `src/lib.rs` for library code and `src/main.rs` for binary entry point
- Place CLI-specific code in the `cli/` directory
- Keep examples in the `examples/` directory
- Place benchmarks in the `benches/` directory

### Dependencies

- Use async/await with `tokio` for I/O operations
- Use `reqwest` with rustls for HTTP requests
- Use `serde` for serialization/deserialization
- Use `tree-sitter` for code parsing and analysis
- Use `walkdir` and `glob` for file system operations

## Development Guidelines

### Error Handling

- Use `anyhow::Result<T>` for functions that can fail
- Provide meaningful error messages with context
- Use `?` operator for error propagation
- Log errors appropriately using `console` crate

### Performance

- Use `tokio` for async operations
- Consider using `futures` for complex async workflows
- Profile with `criterion` benchmarks in the `benches/` directory
- Use `tree-sitter` efficiently for code parsing

### Testing

- Write unit tests in the same file as the code being tested
- Write integration tests in the `tests/` directory
- Use `cargo test` for running tests
- Consider property-based testing for complex algorithms

### Documentation

- Document public APIs with rustdoc comments
- Include examples in documentation
- Keep README.md up to date
- Document CLI usage and examples
- Document (.md) files must put in ./docs folder. don't put any unrelated files in root folder. THIS IS IMPORTANT

## Tree-sitter Integration

- Use tree-sitter parsers for supported languages
- Handle parsing errors gracefully
- Consider performance implications of parsing large files
- Provide meaningful error messages for parsing failures

## CLI Design

- Use `clap` derive macros for argument parsing
- Provide clear help text and examples
- Use `console` and `owo-colors` for colored output
- Use `termimad` for rich terminal output when appropriate

## Security Considerations

- Be careful with file system operations
- Validate input from external sources
- Handle API keys securely (use environment variables)
- Consider rate limiting for external API calls

## Build Configuration

- Use release profile optimizations (codegen-units = 1, opt-level = 3, lto = true)
- Consider using `cargo clippy` for additional linting
- Use `cargo fmt` for code formatting

## File Organization

- Keep related functionality together
- Use appropriate module structure
- Consider the separation between library and binary code
- Place configuration files at the project root

## When Making Changes

- Ensure all tests pass
- Run `cargo clippy` and fix warnings
- Format code with `cargo fmt`
- Update documentation if needed
- Consider performance implications
- Test with various input files and edge cases
- Prefered ripgrep for searching code
- DO NOT USE EMOJI THIS IS IMPORTANT
- Put all agent's configuration option to vtagent.toml. This is important, every logic should be read from this toml config instead of hardcode.
- Use MCP tools for enhanced context awareness if needed.
- Don't explain what you are doing, just do what I asked you.
- AI responses should maintain context awareness across conversations
- Tool integrations must handle timeouts and error recovery gracefully
- UI components should provide non-blocking status feedback
- Configuration changes require documentation updates
- New commands should follow the existing pattern in `commands/` module
- Use MCP tools for enhanced context awareness and external service integration
- All agent config should be in `vtagent.toml` (no hardcoding)
- Environment variables for sensitive data (API keys)

## Code Quality & Maintainability Principles

Write code for **human brains, not machines**. Prioritize simplicity and maintainability. Human working memory holds ~4 chunks max—complex code feels mentally taxing.

**Bad example** (overloads working memory):
```
if val > someConstant // (1 fact)
    && (condition2 || condition3) // (3 facts: prev true, c2|c3 true)
    && (condition4 && !condition5) { // (memory overload)
    ...
}
```

**Good example** (clean working memory):
```
isValid = val > someConstant
isAllowed = condition2 || condition3
isSecure = condition4 && !condition5
// (memory clean: descriptive variables)
if isValid && isAllowed && isSecure {
    ...
}
```

**Guidelines:**
- Write only "WHY" comments—explain motivation, complex logic, or high-level overview. Avoid redundant "WHAT" comments.
- Extract complex conditionals into descriptive intermediate variables.
- Prefer early returns over nested ifs—focus reader on happy path.
- Favor composition over deep inheritance hierarchies.
- Avoid shallow modules (complex interfaces, simple functionality)—prefer deep modules (simple interface, complex functionality).
- Use minimal language features—readers shouldn't need advanced language knowledge.
- Choose self-descriptive values over custom mappings requiring memorization.
- Accept some duplication over unnecessary dependencies (don't abuse DRY).
- Minimize abstraction layers—linear thinking is more natural than jumping between abstractions.



<!-- Source: .ruler/AGENTS.md -->

# AGENTS.md

## Build Commands
- **Build**: `cargo build --workspace`
- **Release build**: `cargo build --workspace --release`
- **Run**: `cargo run` or `./run.sh`

## Testing Commands
- **All tests**: `cargo test --workspace`
- **Single test**: `cargo test function_name` or `cargo test --package vtagent-core -- path::to::test`
- **Integration tests**: `cargo test --test integration_tests`

## Code Quality Commands
- **Format check**: `cargo fmt --all -- --check`
- **Auto-format**: `cargo fmt --all`
- **Lint**: `cargo clippy --workspace --all-targets --all-features -- -D warnings`
- **All checks**: `./scripts/check.sh`

## Rust Code Style Guidelines

### Naming & Structure
- Functions/variables: `snake_case`
- Types/structs: `PascalCase`
- Modules: `snake_case` with meaningful names
- Constants: `SCREAMING_SNAKE_CASE`

### Error Handling
- Use `anyhow::Result<T>` for fallible operations
- Prefer `thiserror` for custom error types
- Use `?` operator for error propagation
- Provide descriptive error contexts

### Async Code
- Use `tokio` for I/O operations with features: `rt-multi-thread`, `fs`, `macros`
- Leverage `futures` for complex async workflows
- Use `async_file_ops` for file operations

### Dependencies
- Serialization: `serde` with derive macros
- HTTP requests: `reqwest` with rustls
- File operations: `walkdir` and `glob`
- Source parsing: tree-sitter variants (rust, python, javascript, typescript, go, java)

### Code Organization
- `src/lib.rs` for library code
- `src/main.rs` for binary entry
- Separate CLI code in `cli/` directory
- Examples in `examples/` directory
- Benchmarks in `benches/` directory

### CLI Patterns
- Use `clap` with derive macros
- `console` + `owo-colors` for colored terminal output
- `termimad` for rich markdown rendering
- `is-terminal` for output format detection

### Tree-sitter Integration
- Language support: Rust, Python, JavaScript, TypeScript, Go, Java
- Handle parse errors gracefully with meaningful messages
- Consider performance for large files
- Use `tree_sitter` crate efficiently

### Development Guidelines
- Unit tests alongside implementation code
- Integration tests in `tests/` directory
- Profile with benchmarks (`cargo bench`)
- Use `cargo clippy` and fix all warnings
- Format with `cargo fmt`

### Config Management
- All agent config in `vtagent.toml` (no hardcoding)
- Environment variables for sensitive data (API keys)
- Use MCP tools for enhanced context awareness

### GitHub Actions
- CI workflow in `.github/workflows/code-quality.yml`
- Rust/Cargo setup with appropriate toolchain
- Automated linting, tests, and formatting checks

### Important Rules
- Do NOT use emojis in any content
- Document (.md) files must be in `/docs` folder only
- Security: validate external inputs, handle API keys securely
- Performance: efficient async ops, tree-sitter usage# CRUSH - vtagent Project Configuration

## Build Commands
- **Build**: `cargo build --workspace`
- **Release build**: `cargo build --workspace --release`
- **Run**: `cargo run` or `./run.sh`

## Testing Commands
- **All tests**: `cargo test --workspace`
- **Single test**: `cargo test function_name` or `cargo test --package vtagent-core -- path::to::test`
- **Integration tests**: `cargo test --test integration_tests`

## Code Quality Commands
- **Format check**: `cargo fmt --all -- --check`
- **Auto-format**: `cargo fmt --all`
- **Lint**: `cargo clippy --workspace --all-targets --all-features -- -D warnings`
- **All checks**: `./scripts/check.sh`

## Rust Code Style Guidelines

### Naming & Structure
- Functions/variables: `snake_case`
- Types/structs: `PascalCase`
- Modules: `snake_case` with meaningful names
- Constants: `SCREAMING_SNAKE_CASE`

### Error Handling
- Use `anyhow::Result<T>` for fallible operations
- Prefer `thiserror` for custom error types
- Use `?` operator for error propagation
- Provide descriptive error contexts

### Async Code
- Use `tokio` for I/O operations with features: `rt-multi-thread`, `fs`, `macros`
- Leverage `futures` for complex async workflows
- Use `async_file_ops` for file operations

### Dependencies
- Serialization: `serde` with derive macros
- HTTP requests: `reqwest` with rustls
- File operations: `walkdir` and `glob`
- Source parsing: tree-sitter variants (rust, python, javascript, typescript, go, java)

### Code Organization
- `src/lib.rs` for library code
- `src/main.rs` for binary entry
- Separate CLI code in `cli/` directory
- Examples in `examples/` directory
- Benchmarks in `benches/` directory

### CLI Patterns
- Use `clap` with derive macros
- `console` + `owo-colors` for colored terminal output
- `termimad` for rich markdown rendering
- `is-terminal` for output format detection

### Tree-sitter Integration
- Language support: Rust, Python, JavaScript, TypeScript, Go, Java
- Handle parse errors gracefully with meaningful messages
- Consider performance for large files
- Use `tree_sitter` crate efficiently

### Development Guidelines
- Unit tests alongside implementation code
- Integration tests in `tests/` directory
- Profile with benchmarks (`cargo bench`)
- Use `cargo clippy` and fix all warnings
- Format with `cargo fmt`

### Config Management
- All agent config in `vtagent.toml` (no hardcoding)
- Environment variables for sensitive data (API keys)
- Use MCP tools for enhanced context awareness

### GitHub Actions
- CI workflow in `.github/workflows/code-quality.yml`
- Rust/Cargo setup with appropriate toolchain
- Automated linting, tests, and formatting checks

### Important Rules
- Do NOT use emojis in any content
- Document (.md) files must be in `/docs` folder only
- Security: validate external inputs, handle API keys securely
- Performance: efficient async ops, tree-sitter usage
- For echo test, don't use "!" exclamation mark to avoid system command escape issues
- Use `sd` instead of `sed` for safer in-place edits
- Use `rip2` instead of `rm` to prevent accidental deletions
- Use `rp` instead of `grep` for safer recursive searches
