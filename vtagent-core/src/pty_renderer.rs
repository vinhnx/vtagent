//! PTY output renderer with ANSI color support\n//!\n//! This module provides functionality to render PTY command output in a terminal-like\n//! interface with proper ANSI color support.\n\nuse anyhow::Result;\nuse console::{style, Style};\nuse std::io::Write;\n\n/// Render PTY output in a terminal-like interface with ANSI color support\npub fn render_pty_output(output: &str, title: &str, command: Option<&str>) -> Result<()> {\n    // Print top border\n    println!(\"{}\", style(\"=\").repeat(80).dim());\n    \n    // Print title\n    println!(\"{} {}\", style(\"==\").blue().bold(), style(title).blue().bold());\n    \n    // Print command if available\n    if let Some(cmd) = command {\n        println!(\"{}\", style(format!(\"> {}\", cmd)).dim());\n    }\n    \n    // Print separator\n    println!(\"{}\", style(\"-\".repeat(80)).dim());\n    \n    // Print the output with ANSI color support\n    render_ansi_colored_output(output)?;\n    \n    // Print bottom border\n    println!(\"{}\", style(\"-\".repeat(80)).dim());\n    println!(\"{}\", style(\"==\").blue().bold());\n    println!(\"{}\", style(\"=\").repeat(80).dim());\n    \n    Ok(())\n}\n\n/// Render output with ANSI color support\nfn render_ansi_colored_output(output: &str) -> Result<()> {\n    // For now, we'll just print the output as-is to preserve ANSI codes\n    // In a more advanced implementation, we could parse and render colors explicitly\n    print!(\"{}\", output);\n    std::io::stdout().flush()?;\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_render_pty_output() {\n        let output = \"Hello, world!\\nThis is a test.\";\n        let title = \"Test Output\";\n        let command = Some(\"echo 'Hello, world!'\");\n        \n        // This should not panic\n        assert!(render_pty_output(output, title, command).is_ok());\n    }\n}