//! anstyle-parse utilities for processing ANSI escape sequences\n//!\n//! This module provides utilities for parsing and processing ANSI escape sequences\n//! using the anstyle-parse crate, which offers robust parsing of terminal output.\n\n#[cfg(feature = \"anstyle-parse\")]\nuse anstyle_parse::{Parser, Params, Perform, Utf8Parser};\n\n/// A parser for ANSI escape sequences that can process terminal output\n#[cfg(feature = \"anstyle-parse\")]\npub struct AnsiEscapeParser {\n    parser: Parser<Utf8Parser>,\n    collected_text: String,\n    collected_sequences: Vec<AnsiSequence>,\n}\n\n/// Represents a parsed ANSI escape sequence\n#[cfg(feature = \"anstyle-parse\")]\n#[derive(Debug, Clone)]\npub enum AnsiSequence {\n    /// Control Sequence Introducer (CSI) sequence\n    Csi {\n        params: Vec<u16>,\n        intermediates: Vec<u8>,\n        ignore: bool,\n        action: u8,\n    },\n    /// Operating System Command (OSC) sequence\n    Osc {\n        params: Vec<Vec<u8>>,\n        bell_terminated: bool,\n    },\n    /// Escape sequence\n    Esc {\n        intermediates: Vec<u8>,\n        ignore: bool,\n        byte: u8,\n    },\n    /// Hook sequence\n    Hook {\n        params: Vec<u16>,\n        intermediates: Vec<u8>,\n        ignore: bool,\n        action: u8,\n    },\n    /// Put sequence\n    Put {\n        byte: u8,\n    },\n    /// Unhook sequence\n    Unhook,\n}\n\n#[cfg(feature = \"anstyle-parse\")]\nimpl AnsiEscapeParser {\n    /// Create a new ANSI escape sequence parser\n    pub fn new() -> Self {\n        Self {\n            parser: Parser::new(),\n            collected_text: String::new(),\n            collected_sequences: Vec::new(),\n        }\n    }\n\n    /// Process a chunk of terminal output, parsing any ANSI escape sequences\n    pub fn process(&mut self, data: &[u8]) {\n        for &byte in data {\n            self.parser.advance(self, byte);\n        }\n    }\n\n    /// Get the collected text (without ANSI escape sequences)\n    pub fn text(&self) -> &str {\n        &self.collected_text\n    }\n\n    /// Get the collected ANSI escape sequences\n    pub fn sequences(&self) -> &[AnsiSequence] {\n        &self.collected_sequences\n    }\n\n    /// Clear the collected data\n    pub fn clear(&mut self) {\n        self.collected_text.clear();\n        self.collected_sequences.clear();\n    }\n}\n\n#[cfg(feature = \"anstyle-parse\")]\nimpl Perform for AnsiEscapeParser {\n    fn print(&mut self, character: char) {\n        self.collected_text.push(character);\n    }\n\n    fn execute(&mut self, byte: u8) {\n        // Handle control characters\n        if byte == b'\\n' {\n            self.collected_text.push('\\n');\n        } else if byte == b'\\r' {\n            // Carriage return - typically handled by terminal\n        } else if byte == b'\\t' {\n            self.collected_text.push('\\t');\n        }\n        // Other control characters are ignored for simplicity\n    }\n\n    fn hook(&mut self, params: &Params, intermediates: &[u8], ignore: bool, action: u8) {\n        self.collected_sequences.push(AnsiSequence::Hook {\n            params: params.iter().map(|p| p as u16).collect(),\n            intermediates: intermediates.to_vec(),\n            ignore,\n            action,\n        });\n    }\n\n    fn put(&mut self, byte: u8) {\n        self.collected_sequences.push(AnsiSequence::Put { byte });\n    }\n\n    fn unhook(&mut self) {\n        self.collected_sequences.push(AnsiSequence::Unhook);\n    }\n\n    fn osc_dispatch(&mut self, params: &[&[u8]], bell_terminated: bool) {\n        self.collected_sequences.push(AnsiSequence::Osc {\n            params: params.iter().map(|p| p.to_vec()).collect(),\n            bell_terminated,\n        });\n    }\n\n    fn csi_dispatch(&mut self, params: &Params, intermediates: &[u8], ignore: bool, action: u8) {\n        self.collected_sequences.push(AnsiSequence::Csi {\n            params: params.iter().map(|p| p as u16).collect(),\n            intermediates: intermediates.to_vec(),\n            ignore,\n            action,\n        });\n    }\n\n    fn esc_dispatch(&mut self, intermediates: &[u8], ignore: bool, byte: u8) {\n        self.collected_sequences.push(AnsiSequence::Esc {\n            intermediates: intermediates.to_vec(),\n            ignore,\n            byte,\n        });\n    }\n}\n\n/// Strip ANSI escape sequences from text\n#[cfg(feature = \"anstyle-parse\")]\npub fn strip_ansi_escapes(text: &str) -> String {\n    let mut parser = AnsiEscapeParser::new();\n    parser.process(text.as_bytes());\n    parser.text().to_string()\n}\n\n/// Check if text contains ANSI escape sequences\n#[cfg(feature = \"anstyle-parse\")]\npub fn contains_ansi_escapes(text: &str) -> bool {\n    // Simple heuristic: look for common escape sequence patterns\n    text.contains('\\x1b') && (text.contains('[') || text.contains(']') || text.contains('\\\\'))\n}\n\n#[cfg(all(test, feature = \"anstyle-parse\"))]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_strip_ansi_escapes() {\n        let input = \"\\x1b[31mRed Text\\x1b[0m Normal Text\";\n        let expected = \"Red Text Normal Text\";\n        let result = strip_ansi_escapes(input);\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_contains_ansi_escapes() {\n        assert!(contains_ansi_escapes(\"\\x1b[31mRed Text\\x1b[0m\"));\n        assert!(!contains_ansi_escapes(\"Normal Text\"));\n        assert!(contains_ansi_escapes(\"\\x1b]8;;http://example.com\\x1b\\\\Link\\x1b]8;;\\x1b\\\\\"));\n    }\n\n    #[test]\n    fn test_parser_collects_sequences() {\n        let mut parser = AnsiEscapeParser::new();\n        let input = \"\\x1b[31mRed Text\\x1b[0m\";\n        parser.process(input.as_bytes());\n        \n        assert_eq!(parser.text(), \"Red Text\");\n        assert!(!parser.sequences().is_empty());\n    }\n}
